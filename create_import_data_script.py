def create_import_data_script():
    """创建导入历史数据的脚本"""
    script_lines = [
        "#!/usr/bin/env python3",
        "# -*- coding: utf-8 -*-",
        "",
        "import os",
        "import sys",
        "import subprocess",
        "import time",
        "import logging",
        "import threading",  # 使用线程替代信号",
        "import atexit",     # 添加退出处理",
        "from datetime import datetime",
        "",
        "# 配置日志",
        "logging.basicConfig(",
        "    level=logging.INFO,",
        "    format='%(asctime)s - %(levelname)s - %(message)s',",
        "    datefmt='%Y-%m-%d %H:%M:%S'",
        ")",
        "",
        "# 注册退出处理函数",
        "def exit_handler():",
        "    logging.info(\"脚本正在退出，确保所有资源已释放\")",
        "",
        "atexit.register(exit_handler)",
        "",
        "class CommandRunner:",
        "    \"\"\"跨平台的命令执行器，支持超时\"\"\"",
        "    def __init__(self, cmd, timeout=60, shell=True):",
        "        self.cmd = cmd",
        "        self.timeout = timeout",
        "        self.shell = shell",
        "        self.process = None",
        "        self.stdout = ''",
        "        self.stderr = ''",
        "        self.returncode = None",
        "        self.timed_out = False",
        "    ",
        "    def run_command(self):",
        "        \"\"\"在线程中执行命令\"\"\"",
        "        try:",
        "            logging.info(f\"开始执行子进程: {self.cmd}\")",
        "            self.process = subprocess.Popen(",
        "                self.cmd,",
        "                shell=self.shell,",
        "                stdout=subprocess.PIPE,",
        "                stderr=subprocess.PIPE,",
        "                text=True",
        "            )",
        "            logging.info(f\"子进程已启动，PID: {self.process.pid if self.process else 'unknown'}\")",
        "            self.stdout, self.stderr = self.process.communicate()",
        "            self.returncode = self.process.returncode",
        "            logging.info(f\"子进程已完成，返回码: {self.returncode}\")",
        "        except Exception as e:",
        "            logging.error(f\"执行子进程时出错: {e}\")",
        "            self.stderr = str(e)",
        "            self.returncode = -1",
        "    ",
        "    def run(self):",
        "        \"\"\"运行命令并处理超时\"\"\"",
        "        logging.info(f\"准备执行命令: {self.cmd}\")",
        "        ",
        "        # 创建并启动线程",
        "        thread = threading.Thread(target=self.run_command)",
        "        thread.daemon = True  # 设置为守护线程",
        "        thread.start()",
        "        logging.info(f\"命令执行线程已启动\")",
        "        ",
        "        # 等待线程完成或超时",
        "        logging.info(f\"等待命令完成，超时时间: {self.timeout}秒\")",
        "        thread.join(self.timeout)",
        "        ",
        "        # 检查是否超时",
        "        if thread.is_alive():",
        "            self.timed_out = True",
        "            logging.error(f\"命令执行超时: {self.cmd}\")",
        "            ",
        "            # 尝试终止进程",
        "            if self.process:",
        "                try:",
        "                    logging.info(f\"尝试终止超时进程 PID: {self.process.pid if self.process else 'unknown'}\")",
        "                    self.process.terminate()",
        "                    time.sleep(0.5)",
        "                    if self.process.poll() is None:",
        "                        logging.info(f\"进程未响应终止信号，尝试强制终止\")",
        "                        self.process.kill()",
        "                except Exception as e:",
        "                    logging.error(f\"终止进程时出错: {e}\")",
        "            ",
        "            self.returncode = -1",
        "            self.stderr = \"Command timed out\"",
        "            return False",
        "        ",
        "        # 记录命令执行结果",
        "        if self.returncode != 0:",
        "            logging.warning(f\"命令返回非零状态码: {self.returncode}\")",
        "            logging.warning(f\"标准输出: {self.stdout[:500]}...\" if len(self.stdout) > 500 else f\"标准输出: {self.stdout}\")",
        "            logging.warning(f\"标准错误: {self.stderr[:500]}...\" if len(self.stderr) > 500 else f\"标准错误: {self.stderr}\")",
        "            return False",
        "        ",
        "        logging.info(f\"命令执行成功\")",
        "        return True",
        "",
        "def main():",
        "    start_time = datetime.now()",
        "    logging.info(f\"脚本开始执行时间: {start_time}\")",
        "    logging.info(\"开始导入历史数据...\")",
        "    ",
        "    # 检查是否存在导入脚本",
        "    if not os.path.exists('import_historical_data.py'):",
        "        logging.error(\"导入脚本文件不存在: import_historical_data.py\")",
        "        sys.exit(1)",
        "    ",
        "    # 运行导入脚本，添加批处理大小参数".
        "    try:",
        "        logging.info(\"执行导入脚本...\")",
        "        # 直接使用subprocess运行，不使用CommandRunner，避免可能的线程问题",
        "        logging.info(\"使用直接方式执行导入脚本\")",
        "        subprocess_cmd = 'python import_historical_data.py --batch-size 5000'",
        "        logging.info(f\"执行命令: {subprocess_cmd}\")",
        "        ",
        "        # 使用subprocess.run而不是Popen，确保脚本等待子进程完成",
        "        result = subprocess.run(subprocess_cmd, shell=True, capture_output=True, text=True)",
        "        ",
        "        if result.returncode == 0:",
        "            logging.info(\"历史数据导入完成\")",
        "            # 记录输出的最后几行",
        "            output_lines = result.stdout.splitlines()",
        "            if output_lines:",
        "                last_lines = output_lines[-10:] if len(output_lines) > 10 else output_lines",
        "                logging.info(f\"导入脚本最后几行输出: {last_lines}\")",
        "        else:",
        "            logging.error(f\"导入脚本执行失败，返回码: {result.returncode}\")",
        "            logging.error(f\"输出: {result.stdout[-1000:] if len(result.stdout) > 1000 else result.stdout}\")",
        "            logging.error(f\"错误: {result.stderr[-1000:] if len(result.stderr) > 1000 else result.stderr}\")",
        "            sys.exit(1)",
        "    except Exception as e:",
        "        logging.error(f\"导入过程中发生错误: {e}\")",
        "        import traceback",
        "        logging.error(traceback.format_exc())",
        "        sys.exit(1)",
        "    ",
        "    logging.info(\"导入脚本执行完成，继续后续步骤\")",
        "    ",
        "    # 检查文件是否存在",
        "    logging.info(\"检查导入结果文件...\")",
        "    if not os.path.exists('domains_rankings.parquet'):",
        "        logging.error(\"domains_rankings.parquet 文件不存在，跳过Git操作\")",
        "        sys.exit(1)",
        "    ",
        "    if not os.path.exists('domains_first_seen.parquet'):",
        "        logging.error(\"domains_first_seen.parquet 文件不存在，跳过Git操作\")",
        "        sys.exit(1)",
        "    ",
        "    # 检查文件大小",
        "    rankings_size = os.path.getsize('domains_rankings.parquet')",
        "    first_seen_size = os.path.getsize('domains_first_seen.parquet')",
        "    logging.info(f\"domains_rankings.parquet 文件大小: {rankings_size} 字节\")",
        "    logging.info(f\"domains_first_seen.parquet 文件大小: {first_seen_size} 字节\")",
        "    ",
        "    # 提交更改",
        "    try:",
        "        # 配置Git",
        "        logging.info(\"配置Git用户信息...\")",
        "        subprocess.run('git config --local user.email \"actions@github.com\"', shell=True, check=True)",
        "        subprocess.run('git config --local user.name \"GitHub Actions\"', shell=True, check=True)",
        "        ",
        "        # 检查Git状态",
        "        logging.info(\"检查Git状态...\")",
        "        status_result = subprocess.run('git status', shell=True, capture_output=True, text=True)",
        "        logging.info(f\"Git状态: {status_result.stdout}\")",
        "        ",
        "        # 添加文件",
        "        logging.info(\"添加文件到Git...\")",
        "        add_result = subprocess.run('git add domains_rankings.parquet domains_first_seen.parquet', shell=True, capture_output=True, text=True)",
        "        if add_result.returncode == 0:",
        "            logging.info(\"文件添加成功\")",
        "        else:",
        "            logging.error(f\"文件添加失败: {add_result.stderr}\")",
        "        ",
        "        # 提交更改",
        "        logging.info(\"提交更改到Git...\")",
        "        commit_result = subprocess.run('git commit -m \"Import historical domain rank data\"', shell=True, capture_output=True, text=True)",
        "        if commit_result.returncode == 0:",
        "            logging.info(\"更改已提交\")",
        "            ",
        "            # 推送更改",
        "            logging.info(\"推送更改到远程仓库...\")",
        "            push_result = subprocess.run('git push', shell=True, capture_output=True, text=True)",
        "            if push_result.returncode == 0:",
        "                logging.info(\"更改已推送到远程仓库\")",
        "            else:",
        "                logging.error(f\"推送失败: {push_result.stdout}\")",
        "                logging.error(f\"错误: {push_result.stderr}\")",
        "        else:",
        "            logging.info(f\"没有更改需要提交或提交失败: {commit_result.stdout}\")",
        "            if commit_result.stderr:",
        "                logging.info(f\"提交错误: {commit_result.stderr}\")",
        "    except Exception as e:",
        "        logging.error(f\"Git操作过程中发生错误: {e}\")",
        "        import traceback",
        "        logging.error(traceback.format_exc())",
        "    ",
        "    end_time = datetime.now()",
        "    duration = end_time - start_time",
        "    logging.info(f\"脚本结束执行时间: {end_time}\")",
        "    logging.info(f\"总执行时间: {duration}\")",
        "    logging.info(\"导入和提交过程完成\")",
        "",
        "if __name__ == \"__main__\":",
        "    try:",
        "        main()",
        "    except Exception as e:",
        "        logging.error(f\"主程序执行出错: {e}\")",
        "        import traceback",
        "        logging.error(traceback.format_exc())",
        "        sys.exit(1)"