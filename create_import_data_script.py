def create_import_data_script():
    """创建导入历史数据的脚本"""
    script_lines = [
        "#!/usr/bin/env python3",
        "# -*- coding: utf-8 -*-",
        "",
        "import os",
        "import sys",
        "import subprocess",
        "import time",
        "import logging",
        "import threading",
        "import atexit",
        "import signal",
        "from datetime import datetime",
        "",
        "# 配置日志",
        "logging.basicConfig(",
        "    level=logging.INFO,",
        "    format='%(asctime)s - %(levelname)s - %(message)s',",
        "    datefmt='%Y-%m-%d %H:%M:%S'",
        ")",
        "",
        "# 注册退出处理函数",
        "def exit_handler():",
        "    logging.info(\"脚本正在退出，确保所有资源已释放\")",
        "",
        "atexit.register(exit_handler)",
        "",
        "def run_with_timeout(cmd, timeout=300):",
        "    \"\"\"使用超时运行命令，适用于Windows和Unix\"\"\"",
        "    logging.info(f\"执行命令(超时{timeout}秒): {cmd}\")",
        "    ",
        "    # 创建进程",
        "    process = subprocess.Popen(",
        "        cmd,",
        "        shell=True,",
        "        stdout=subprocess.PIPE,",
        "        stderr=subprocess.PIPE,",
        "        text=True,",
        "        creationflags=subprocess.CREATE_NEW_PROCESS_GROUP if os.name == 'nt' else 0",
        "    )",
        "    ",
        "    pid = process.pid",
        "    logging.info(f\"进程已启动，PID: {pid}\")",
        "    ",
        "    # 设置超时",
        "    start_time = time.time()",
        "    output = {'stdout': '', 'stderr': '', 'returncode': None, 'timed_out': False}",
        "    ",
        "    # 读取输出的线程函数",
        "    def read_output():",
        "        stdout, stderr = process.communicate()",
        "        output['stdout'] = stdout",
        "        output['stderr'] = stderr",
        "        output['returncode'] = process.returncode",
        "    ",
        "    # 启动读取线程",
        "    reader_thread = threading.Thread(target=read_output)",
        "    reader_thread.daemon = True",
        "    reader_thread.start()",
        "    ",
        "    # 等待进程完成或超时",
        "    while reader_thread.is_alive():",
        "        if time.time() - start_time > timeout:",
        "            logging.warning(f\"命令执行超时({timeout}秒): {cmd}\")",
        "            output['timed_out'] = True",
        "            ",
        "            # 尝试终止进程",
        "            try:",
        "                logging.info(f\"尝试终止进程 PID: {pid}\")",
        "                if os.name == 'nt':",
        "                    # Windows特定的终止方法",
        "                    os.kill(pid, signal.CTRL_BREAK_EVENT)",
        "                    time.sleep(1)",
        "                    if process.poll() is None:",
        "                        process.kill()",
        "                else:",
        "                    # Unix特定的终止方法",
        "                    process.terminate()",
        "                    time.sleep(1)",
        "                    if process.poll() is None:",
        "                        process.kill()",
        "            except Exception as e:",
        "                logging.error(f\"终止进程时出错: {e}\")",
        "            ",
        "            break",
        "        ",
        "        # 短暂休眠，避免CPU占用过高",
        "        time.sleep(0.5)",
        "    ",
        "    # 确保进程已终止",
        "    if process.poll() is None:",
        "        try:",
        "            process.kill()",
        "            logging.warning(\"强制终止进程\")",
        "        except:",
        "            pass",
        "    ",
        "    return output",
        "",
        "def main():",
        "    start_time = datetime.now()",
        "    logging.info(f\"脚本开始执行时间: {start_time}\")",
        "    logging.info(\"开始导入历史数据...\")",
        "    ",
        "    # 检查是否存在导入脚本",
        "    if not os.path.exists('import_historical_data.py'):",
        "        logging.error(\"导入脚本文件不存在: import_historical_data.py\")",
        "        sys.exit(1)",
        "    ",
        "    # 运行导入脚本，添加批处理大小参数",  # 修复了这里的语法错误，将句号改为逗号
        "    try:",
        "        logging.info(\"执行导入脚本...\")",
        "        subprocess_cmd = 'python import_historical_data.py --batch-size 5000'",
        "        ",
        "        # 使用超时运行命令",
        "        result = run_with_timeout(subprocess_cmd, timeout=300)  # 减少超时时间到5分钟，避免长时间等待",
        "        ",
        "        if result['timed_out']:",
        "            logging.warning(\"导入脚本执行超时，但继续后续步骤\")",
        "            # 即使超时也继续执行，因为数据可能已经更新完成",
        "        elif result['returncode'] == 0:",
        "            logging.info(\"历史数据导入完成\")",
        "            # 记录输出的最后几行",
        "            output_lines = result['stdout'].splitlines()",
        "            if output_lines:",
        "                last_lines = output_lines[-10:] if len(output_lines) > 10 else output_lines",
        "                logging.info(f\"导入脚本最后几行输出: {last_lines}\")",
        "        else:",
        "            logging.error(f\"导入脚本执行失败，返回码: {result['returncode']}\")",
        "            logging.error(f\"输出: {result['stdout'][-1000:] if len(result['stdout']) > 1000 else result['stdout']}\")",
        "            logging.error(f\"错误: {result['stderr'][-1000:] if len(result['stderr']) > 1000 else result['stderr']}\")",
        "            # 即使失败也继续执行，尝试提交可能已经生成的文件",
        "    except Exception as e:",
        "        logging.error(f\"导入过程中发生错误: {e}\")",
        "        import traceback",
        "        logging.error(traceback.format_exc())",
        "        # 继续执行，尝试提交可能已经生成的文件",
        "    ",
        "    # 强制检查文件是否存在，无论导入脚本是否正常完成",
        "    logging.info(\"继续后续步骤，无论导入脚本是否正常完成\")",
        "    logging.info(\"检查导入结果文件...\")",
        "    ",
        "    # 等待一段时间，确保文件写入完成",
        "    logging.info(\"等待5秒钟确保文件写入完成...\")",
        "    time.sleep(5)",
        "    ",
        "    files_exist = True",
        "    ",
        "    if not os.path.exists('domains_rankings.parquet'):",
        "        logging.error(\"domains_rankings.parquet 文件不存在\")",
        "        files_exist = False",
        "    else:",
        "        rankings_size = os.path.getsize('domains_rankings.parquet')",
        "        logging.info(f\"domains_rankings.parquet 文件大小: {rankings_size} 字节\")",
        "    ",
        "    if not os.path.exists('domains_first_seen.parquet'):",
        "        logging.error(\"domains_first_seen.parquet 文件不存在\")",
        "        files_exist = False",
        "    else:",
        "        first_seen_size = os.path.getsize('domains_first_seen.parquet')",
        "        logging.info(f\"domains_first_seen.parquet 文件大小: {first_seen_size} 字节\")",
        "    ",
        "    if not files_exist:",
        "        logging.error(\"缺少必要的结果文件，跳过Git操作\")",
        "        sys.exit(1)",
        "    ",
        "    # 提交更改",
        "    try:",
        "        # 配置Git",
        "        logging.info(\"配置Git用户信息...\")",
        "        subprocess.run('git config --local user.email \"actions@github.com\"', shell=True, check=True)",
        "        subprocess.run('git config --local user.name \"GitHub Actions\"', shell=True, check=True)",
        "        ",
        "        # 检查Git状态",
        "        logging.info(\"检查Git状态...\")",
        "        status_result = subprocess.run('git status', shell=True, capture_output=True, text=True)",
        "        logging.info(f\"Git状态: {status_result.stdout}\")",
        "        ",
        "        # 添加文件",
        "        logging.info(\"添加文件到Git...\")",
        "        add_result = subprocess.run('git add domains_rankings.parquet domains_first_seen.parquet', shell=True, capture_output=True, text=True)",
        "        if add_result.returncode == 0:",
        "            logging.info(\"文件添加成功\")",
        "        else:",
        "            logging.error(f\"文件添加失败: {add_result.stderr}\")",
        "        ",
        "        # 提交更改",
        "        logging.info(\"提交更改到Git...\")",
        "        commit_result = subprocess.run('git commit -m \"Import historical domain rank data\"', shell=True, capture_output=True, text=True)",
        "        if commit_result.returncode == 0:",
        "            logging.info(\"更改已提交\")",
        "            ",
        "            # 推送更改",
        "            logging.info(\"推送更改到远程仓库...\")",
        "            push_result = subprocess.run('git push', shell=True, capture_output=True, text=True)",
        "            if push_result.returncode == 0:",
        "                logging.info(\"更改已推送到远程仓库\")",
        "            else:",
        "                logging.error(f\"推送失败: {push_result.stdout}\")",
        "                logging.error(f\"错误: {push_result.stderr}\")",
        "        else:",
        "            logging.info(f\"没有更改需要提交或提交失败: {commit_result.stdout}\")",
        "            if commit_result.stderr:",
        "                logging.info(f\"提交错误: {commit_result.stderr}\")",
        "    except Exception as e:",
        "        logging.error(f\"Git操作过程中发生错误: {e}\")",
        "        import traceback",
        "        logging.error(traceback.format_exc())",
        "    ",
        "    end_time = datetime.now()",
        "    duration = end_time - start_time",
        "    logging.info(f\"脚本结束执行时间: {end_time}\")",
        "    logging.info(f\"总执行时间: {duration}\")",
        "    logging.info(\"导入和提交过程完成\")",
        "",
        "if __name__ == \"__main__\":",
        "    try:",
        "        main()",
        "    except Exception as e:",
        "        logging.error(f\"主程序执行出错: {e}\")",
        "        import traceback",
        "        logging.error(traceback.format_exc())",
        "        sys.exit(1)"