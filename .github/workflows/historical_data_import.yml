name: Historical Data Import

on:
  workflow_dispatch:  # 仅允许手动触发
    inputs:
      start_date:
        description: '开始日期 (YYYY-MM-DD)'
        required: false
        default: '2024-06-08'
      end_date:
        description: '结束日期 (YYYY-MM-DD)'
        required: false
        default: '2025-03-25'
      start_chunk:
        description: '开始处理的块ID'
        required: false
        default: '0'
      end_chunk:
        description: '结束处理的块ID'
        required: false
        default: '0'
      batch_size:
        description: '每批处理的域名数量'
        required: false
        default: '5000'
      retry_failed:
        description: '重试失败的块 (true/false)'
        required: false
        default: 'false'

jobs:
  import_historical_data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 获取完整历史记录，以便访问所有提交

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 psutil gitpython pandas pyarrow

      # 创建历史数据目录并下载数据文件
      - name: Create historical data directory and download data
        run: |
          mkdir -p historical_extracts
          
          # 克隆目标仓库以获取提交历史
          echo "克隆目标仓库以获取提交历史..."
          git clone --bare https://github.com/adysec/top_1m_domains.git target_repo
          cd target_repo
          
          # 获取日期范围内的所有提交
          echo "获取提交历史..."
          START_DATE="${{ github.event.inputs.start_date }}"
          END_DATE="${{ github.event.inputs.end_date }}"
          git log --after="${START_DATE}" --before="${END_DATE}" --format="%H %cs" > ../commit_list.txt
          cd ..
          
          # 显示找到的提交数量
          COMMIT_COUNT=$(wc -l < commit_list.txt)
          echo "找到 ${COMMIT_COUNT} 个提交"
          
          # 打印提交列表以便调试
          echo "提交列表内容:"
          cat commit_list.txt
          
          # 为每个提交创建目录并下载数据
          while read -r commit_hash commit_date; do
            echo "=============================================="
            echo "处理提交: ${commit_hash} (${commit_date})"
            echo "完整提交哈希: ${commit_hash}"
            
            # 创建目录
            mkdir -p "historical_extracts/${commit_date}"
            echo "${commit_hash}" > "historical_extracts/${commit_date}/commit_hash.txt"
            
            # 使用完整的提交哈希构建URL
            DOWNLOAD_URL="https://github.com/adysec/top_1m_domains/raw/${commit_hash}/tranco.zip"
            DATE_URL="https://github.com/adysec/top_1m_domains/raw/${commit_hash}/date.txt"
            
            echo "构造的下载URL: ${DOWNLOAD_URL}"
            echo "构造的日期URL: ${DATE_URL}"
            
            # 尝试获取URL头信息并显示详细信息
            echo "检查URL可访问性:"
            curl -v "${DOWNLOAD_URL}" > curl_output.txt 2>&1
            cat curl_output.txt | head -n 20
            
            # 尝试不同的文件名
            echo "尝试其他可能的文件名..."
            ALT_URLS=(
              "https://github.com/adysec/top_1m_domains/raw/${commit_hash}/top-1m.csv"
              "https://github.com/adysec/top_1m_domains/raw/${commit_hash}/top-1m.csv.zip"
              "https://github.com/adysec/top_1m_domains/raw/${commit_hash}/tranco-list.csv"
              "https://github.com/adysec/top_1m_domains/raw/${commit_hash}/tranco-list.csv.zip"
              "https://github.com/adysec/top_1m_domains/raw/${commit_hash}/tranco.csv"
            )
            
            for ALT_URL in "${ALT_URLS[@]}"; do
              echo "检查替代URL: ${ALT_URL}"
              if curl -s -f --head "${ALT_URL}" > /dev/null 2>&1; then
                echo "找到可访问的替代URL: ${ALT_URL}"
                DOWNLOAD_URL="${ALT_URL}"
                break
              fi
            done
            
            # 先检查是否可以访问
            if curl -s -f --head "${DOWNLOAD_URL}" > /dev/null 2>&1; then
              echo "下载数据文件: ${DOWNLOAD_URL}"
              curl -s -o "historical_extracts/${commit_date}/tranco.zip" "${DOWNLOAD_URL}"
              
              # 检查下载文件信息
              echo "下载的文件信息:"
              ls -la "historical_extracts/${commit_date}/tranco.zip"
              file "historical_extracts/${commit_date}/tranco.zip"
              head -n 5 "historical_extracts/${commit_date}/tranco.zip" | cat -A  # 显示文件前几行，包括不可打印字符
              
              # 检查下载是否成功
              if [ -f "historical_extracts/${commit_date}/tranco.zip" ] && [ -s "historical_extracts/${commit_date}/tranco.zip" ]; then
                echo "数据文件已保存到: historical_extracts/${commit_date}/tranco.zip"
                
                # 检查文件类型
                FILE_TYPE=$(file -b "historical_extracts/${commit_date}/tranco.zip")
                echo "文件类型: ${FILE_TYPE}"
                
                if [[ "${FILE_TYPE}" == *"Zip archive"* ]]; then
                  # 解压zip文件
                  echo "解压数据文件..."
                  unzip -q -o "historical_extracts/${commit_date}/tranco.zip" -d "historical_extracts/${commit_date}/"
                else
                  echo "文件不是zip格式，尝试作为CSV处理"
                  # 检查是否为CSV格式
                  if head -n 1 "historical_extracts/${commit_date}/tranco.zip" | grep -q "," || head -n 1 "historical_extracts/${commit_date}/tranco.zip" | grep -q "rank"; then
                    echo "文件似乎是CSV格式，直接复制为top-1m.csv"
                    cp "historical_extracts/${commit_date}/tranco.zip" "historical_extracts/${commit_date}/top-1m.csv"
                  else
                    echo "文件格式无法识别，创建空的top-1m.csv"
                    echo "rank,domain" > "historical_extracts/${commit_date}/top-1m.csv"
                  fi
                fi
                
                # 解压后是否有CSV文件
                if [ -f "historical_extracts/${commit_date}/top-1m.csv" ]; then
                  echo "找到top-1m.csv文件"
                else
                  # 查找任何CSV文件并重命名为top-1m.csv
                  CSV_FILE=$(find "historical_extracts/${commit_date}/" -name "*.csv" | head -n 1)
                  if [ ! -z "${CSV_FILE}" ]; then
                    echo "找到CSV文件: ${CSV_FILE}，重命名为top-1m.csv"
                    cp "${CSV_FILE}" "historical_extracts/${commit_date}/top-1m.csv"
                  else
                    echo "未找到CSV文件，创建空的top-1m.csv"
                    echo "rank,domain" > "historical_extracts/${commit_date}/top-1m.csv"
                  fi
                fi
              else
                echo "下载失败，创建空的top-1m.csv"
                echo "rank,domain" > "historical_extracts/${commit_date}/top-1m.csv"
              fi
            else
              echo "数据文件不存在或无法访问: ${DOWNLOAD_URL}"
              echo "创建空的top-1m.csv"
              echo "rank,domain" > "historical_extracts/${commit_date}/top-1m.csv"
            fi
            
            # 尝试获取date.txt文件
            if curl -s -f --head "${DATE_URL}" > /dev/null 2>&1; then
              echo "下载日期文件: ${DATE_URL}"
              curl -s -o "historical_extracts/${commit_date}/date.txt" "${DATE_URL}"
              echo "日期文件已保存"
            fi
          done < commit_list.txt
          
          # 清理临时仓库
          rm -rf target_repo
          
          # 列出创建的目录和文件
          echo "创建的目录和文件列表:"
          find historical_extracts -type f | sort

      # 运行分块导入
      - name: Run chunked import
        run: |
          # 先检查数据块数量
          echo "检查数据块数量..."
          TOTAL_CHUNKS=$(python -c "
          import os
          commit_dirs = [d for d in os.listdir('historical_extracts') if os.path.isdir(os.path.join('historical_extracts', d))]
          chunk_size = 30
          total_chunks = (len(commit_dirs) + chunk_size - 1) // chunk_size
          print(total_chunks)
          ")
          echo "总数据块数量: ${TOTAL_CHUNKS}"
          
          # 设置结束块ID
          END_CHUNK="${{ github.event.inputs.end_chunk }}"
          if [ -z "${END_CHUNK}" ] || [ "${END_CHUNK}" = "" ]; then
            END_CHUNK=$((TOTAL_CHUNKS - 1))
            echo "设置结束块ID为: ${END_CHUNK}"
          fi
          
          # 设置重试标志
          RETRY_FLAG=""
          if [ "${{ github.event.inputs.retry_failed }}" = "true" ]; then
            RETRY_FLAG="--retry-failed"
          fi
          
          # 运行导入脚本
          echo "运行导入脚本..."
          python run_chunked_import.py --start-chunk ${{ github.event.inputs.start_chunk }} --end-chunk ${END_CHUNK} --batch-size ${{ github.event.inputs.batch_size }} ${RETRY_FLAG}
          
          # 生成每日新域名文件
          echo "生成每日新域名文件..."
          mkdir -p new_domains
          python -c "
          import pandas as pd
          import os
          from datetime import datetime
          
          # 加载域名首次出现数据
          print('加载域名首次出现数据...')
          df_first_seen = pd.read_parquet('domains_first_seen.parquet')
          
          # 获取所有日期目录
          date_dirs = sorted([d for d in os.listdir('historical_extracts') if os.path.isdir(os.path.join('historical_extracts', d))])
          print(f'找到 {len(date_dirs)} 个日期目录')
          
          # 处理每个日期
          for date_str in date_dirs:
              try:
                  # 解析日期
                  date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                  
                  # 查找在该日期首次出现的域名
                  new_domains = df_first_seen[df_first_seen['first_seen'] == date_str]
                  
                  if not new_domains.empty:
                      # 创建输出文件
                      output_file = f'new_domains/{date_str}.csv'
                      new_domains[['domain']].to_csv(output_file, index=False)
                      print(f'已生成 {date_str} 的新域名文件，包含 {len(new_domains)} 个域名')
                  else:
                      print(f'{date_str} 没有新域名')
              except Exception as e:
                  print(f'处理 {date_str} 时出错: {str(e)}')
          
          print('每日新域名文件生成完成')
          "

      # 提交结果
      - name: Commit results
        run: |
          # 检查结果文件
          echo "检查结果文件..."
          
          # 列出当前目录文件
          echo "当前目录文件列表:"
          ls -la
          
          if [ -f "domains_rankings.parquet" ] && [ -f "domains_first_seen.parquet" ]; then
            echo "结果文件存在，准备提交..."
            
            # 配置Git
            git config --local user.email "actions@github.com"
            git config --local user.name "GitHub Actions"
            
            # 显示Git状态
            echo "提交前Git状态:"
            git status
            
            # 强制添加所有生成的文件
            echo "添加文件到Git..."
            git add -f domains_rankings.parquet
            git add -f domains_first_seen.parquet
            
            # 检查new_domains目录是否存在
            if [ -d "new_domains" ]; then
              echo "添加new_domains目录..."
              git add -f new_domains/
            else
              echo "警告: new_domains目录不存在"
              mkdir -p new_domains
              echo "创建了空的new_domains目录"
              git add -f new_domains/
            fi
            
            # 再次显示Git状态
            echo "添加文件后Git状态:"
            git status
            
            # 检查是否有更改
            CHANGES=$(git status --porcelain | grep -v '??' | wc -l)
            echo "检测到 ${CHANGES} 个已暂存的更改"
            
            if [ "$CHANGES" -gt 0 ]; then
              echo "提交更改..."
              git commit -m "Import historical domain rank data and generate new domains files"
              echo "提交成功"
            else
              echo "没有已暂存的更改，尝试强制提交..."
              # 尝试强制提交
              touch .gitkeep
              git add .gitkeep
              git commit -m "Import historical domain rank data (force commit)"
              rm .gitkeep
            fi
          else
            echo "结果文件不存在，跳过提交"
            ls -la
          fi

      - name: Push changes
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: main